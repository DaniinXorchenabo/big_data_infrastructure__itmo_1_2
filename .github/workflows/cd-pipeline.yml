name: Continuous Delivery

on:
  workflow_dispatch:    # Позволяет запускать вручную
    inputs:
      deploy:
        description: 'Choose deploy environment'
        required: true
        default: 'staging'
  schedule:
    - cron: '0 0 1 * *'   # По расписанию
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed         # После завершения CI pipeline

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Set up Docker Compose
      run: |
        sudo apt-get update
        sudo apt-get install -y docker-compose
  

    - name: Copy .env file
      run: |
          cp ./env/example.env ./env/.env
          echo "JUPYTER_TOKEN=${{ secrets.JUPYTER_TOKEN }}" >>  ./env/.env
          echo "AI_WEIGHTS_FILENAME=${{ secrets.AI_WEIGHTS_FILENAME }}" >>  ./env/.env
          echo "AI_WEIGHTS_REPO=${{ secrets.AI_WEIGHTS_REPO }}" >>  ./env/.env
          echo "AI_WEIGHTS_REPO_FILENAME=${{ secrets.AI_WEIGHTS_REPO_FILENAME }}" >>  ./env/.env
          
          echo "CONTAINER_PREFIX=unittests" >>  ./env/.env
          echo "DB_LOGIN=${{ secrets.DB_LOGIN }}" >>  ./env/.env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >>  ./env/.env
          echo "DB_HOST=hbase-rest" >>  ./env/.env
          echo "DB_PORT=${{ secrets.DB_PORT }}" >>  ./env/.env

          cp ./env/.env ./env/unittests.env

    - name: Vault testing secrets
      run: |
        sudo docker-compose -f ./docker/docker-compose.yml --env-file ./env/unittests.env  up  -d --build vault
        sudo docker exec -i  vault mkdir -p /vault/data
        sudo docker exec -i  vault chown -R vault /vault/data
#        sudo docker exec -i  vault vault operator init -format=json
        init_output=$(sudo docker exec -i  vault vault operator init -format=json)
#
#        if [ $? -ne 0 ]; then
#          echo "Ошибка инициализации Vault"
#          exit 1
#        fi
#
#        # Извлекаем unseal-ключи (массив) и root-токен с помощью jq
#        unseal_keys=$(echo "$init_output" | jq -r '.unseal_keys_b64[]')  # unseal_keys_hex
#        root_token=$(echo "$init_output" | jq -r '.root_token')
#
#        # Сохраняем первые три unseal-ключа в переменные окружения
#        export VAULT_UNSEAL_KEY_1="${unseal_keys[0]}"
#        export VAULT_UNSEAL_KEY_2="${unseal_keys[1]}"
#        export VAULT_UNSEAL_KEY_3="${unseal_keys[2]}"
#        export VAULT_UNSEAL_KEY_4="${unseal_keys[3]}"
#        export VAULT_UNSEAL_KEY_5="${unseal_keys[4]}"
#        # При необходимости можно добавить дополнительные ключи
#        #sleep 10s
#        # Сохраняем root-токен
#        export VAULT_ROOT_TOKEN="$root_token"
#
#        echo "Инициализация Vault завершена. Ключи сохранены в переменные окружения:"
#        echo "VAULT_UNSEAL_KEY_1=$VAULT_UNSEAL_KEY_1"
#        echo "VAULT_UNSEAL_KEY_2=$VAULT_UNSEAL_KEY_2"
#        echo "VAULT_UNSEAL_KEY_3=$VAULT_UNSEAL_KEY_3"
#        echo "VAULT_ROOT_TOKEN=$VAULT_ROOT_TOKEN"
        

#    - name: Pull images from Docker Compose
#      run: |
#        docker-compose -f ./docker/docker-compose.yml  --env-file ./env/unittests.env  pull
#
#    - name: Run tests
#      run: |
#        docker-compose -f ./docker/docker-compose.yml --env-file ./env/unittests.env  up  -d
#        docker exec -it dl_labs pytest -c ./tests/pytest.ini
#        TEST_EXIT_CODE=$(docker inspect dl_labs --format='{{.State.ExitCode}}')
#        docker-compose -f ./docker/dev.docker-compose.yml -f ./docker/test.docker-compose.yml --env-file ./env/unittests.env down
#        if [ "$TEST_EXIT_CODE" -ne 0 ]; then
#              echo "Tests failed with exit code $TEST_EXIT_CODE"
#              exit $TEST_EXIT_CODE
#            else
#              echo "Tests passed successfully."
#        fi
#    - name: Shutdown Docker Compose
#      run: |
#        docker-compose -f ./docker/docker-compose.yml --env-file ./env/unittests.env  down

